import net.neoforged.jarcompatibilitychecker.gradle.JCCPlugin
import net.neoforged.jarcompatibilitychecker.gradle.CompatibilityTask
import net.neoforged.moddevgradle.dsl.ModModel
import net.neoforged.neodev.GenerateFinalizeSpawnTargets
import net.neoforged.neodev.ProvideCompatibilityCheckJar
import net.neoforged.neodev.DownloadFile

plugins {
    id 'java-library'
    id 'maven-publish'
    id 'net.neoforged.jarcompatibilitychecker' version '0.1.12'
    id 'net.neoforged.gradleutils'
    id 'neoforge.versioning'
}

apply plugin : net.neoforged.neodev.NeoDevPlugin

// Because of the source set reference.
evaluationDependsOn(":neoforge-coremods")

gradleutils.setupSigning(project: project, signAllPublications: true)

changelog {
    from '21.6'
    disableAutomaticPublicationRegistration()
}

sourceSets {
    main {
        java {
            srcDirs rootProject.file('src/main/java')
        }
        resources {
            srcDirs rootProject.file('src/main/resources'), rootProject.file('src/generated/resources')
        }
    }
    client {
        java {
            srcDirs rootProject.file('src/client/java')
        }
    }
}

java {
    registerFeature('client') {
        usingSourceSet(sourceSets.client)
        disablePublication()
    }
}

final checkVersion = JCCPlugin.providePreviousVersion(
        project.providers, project.providers.provider({['https://maven.neoforged.net/releases']}), project.providers.provider({'net.neoforged:neoforge'}),
        project.provider { project.version }.map { ver -> CompatibilityTask.VersionComponentTest.MINOR.predicate(ver) }
)
def downloadPreviousVersionInstaller = tasks.register('downloadPreviousVersionInstaller', DownloadFile) {
    url = checkVersion.map { "https://maven.neoforged.net/releases/net/neoforged/neoforge/${it}/neoforge-${it}-installer.jar".toString() }
    destination = layout.buildDirectory.file("createCompatibilityCheckJar/installer.jar")
}
final createCompatJar = tasks.register('createCompatibilityCheckJar', ProvideCompatibilityCheckJar) {
    installer.from(downloadPreviousVersionInstaller)
    installationDir = layout.buildDirectory.dir("createCompatibilityCheckJar")
    output = layout.buildDirectory.file("createCompatibilityCheckJar/merged.jar")
    version = checkVersion
    javaLauncher = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(java_version)
    }
}
checkJarCompatibility {
    isAPI = true
    baseJar = createCompatJar.flatMap { it.output }
    inputJar = tasks.named("joinedJar", Jar).flatMap { it.archiveFile }
}

// We don't want to include client in non-client runs,
// however the name of the ModModel must be minecraft for FML to work.
// Since we need both mods to be named minecraft we create them manually.
ext.commonMod = objects.newInstance(ModModel, "minecraft")
commonMod.sourceSet sourceSets.main
ext.joinedMod = objects.newInstance(ModModel, "minecraft")
joinedMod.sourceSet sourceSets.main
joinedMod.sourceSet sourceSets.client

neoDev {
    mods {
        "neoforge-coremods" {
            sourceSet project(":neoforge-coremods").sourceSets.main
        }
    }
}

dependencies {
    // For an overview of what the nonstandard configurations do,
    // have a look at NeoDevConfigurations.java in the buildSrc folder.

    neoFormData("net.neoforged:neoform:${project.minecraft_version}-${project.neoform_version}") {
        capabilities {
            requireCapability 'net.neoforged:neoform'
        }
        endorseStrictVersions()
    }
    neoFormDependencies("net.neoforged:neoform:${project.minecraft_version}-${project.neoform_version}") {
        capabilities {
            requireCapability 'net.neoforged:neoform-dependencies'
        }
        endorseStrictVersions()
    }
    minecraftDependencies("net.neoforged:minecraft-dependencies:${project.minecraft_version}")

    for (var asmModule : ["org.ow2.asm:asm", "org.ow2.asm:asm-commons", "org.ow2.asm:asm-tree", "org.ow2.asm:asm-util", "org.ow2.asm:asm-analysis"]) {
        libraries(asmModule) {
            // Vanilla ships with ASM 9.3 transitively (via their OpenID connect library dependency), we require
            // ASM in a more recent version and have to strictly require this to override the strict Minecraft version.
            version {
                strictly project.asm_version
            }
        }
    }
    libraries ("net.neoforged.fancymodloader:loader:${project.fancy_mod_loader_version}") {
        exclude group: 'org.slf4j'
        exclude group: 'net.fabricmc'
    }
    libraries ("net.neoforged.fancymodloader:earlydisplay:${project.fancy_mod_loader_version}") {
        exclude group: 'org.lwjgl'
        exclude group: 'org.slf4j'
        exclude group: 'net.fabricmc'
    }
    libraries "net.neoforged:accesstransformers:${project.accesstransformers_version}"
    libraries "net.neoforged:bus:${project.eventbus_version}"
    libraries "net.neoforged:mergetool:${project.mergetool_version}:api"
    libraries "com.electronwill.night-config:core:${project.nightconfig_version}"
    libraries "com.electronwill.night-config:toml:${project.nightconfig_version}"
    libraries "org.apache.maven:maven-artifact:${project.apache_maven_artifact_version}"
    libraries "net.jodah:typetools:${project.typetools_version}"
    libraries "net.minecrell:terminalconsoleappender:${project.terminalconsoleappender_version}"
    libraries("net.fabricmc:sponge-mixin:${project.mixin_version}") { transitive = false }
    libraries ("net.neoforged:JarJarSelector:${project.jarjar_version}") {
        exclude group: 'org.slf4j'
    }
    libraries ("net.neoforged:JarJarMetadata:${project.jarjar_version}") {
        exclude group: 'org.slf4j'
    }

    compileOnly "org.jetbrains:annotations:${project.jetbrains_annotations_version}"

    userdevCompileOnly jarJar("io.github.llamalad7:mixinextras-neoforge:${project.mixin_extras_version}")

    userdevTestFixtures("net.neoforged.fancymodloader:junit-fml:${project.fancy_mod_loader_version}") {
        endorseStrictVersions()
    }

    // Must be implementation instead of compileOnly so that running dependent projects such as tests will trigger (re)compilation of coremods.
    // (Only needed when compiling through IntelliJ non-delegated builds - otherwise `compileOnly` would work).
    implementation(jarJar(project(":neoforge-coremods")))

    clientApi(project(":neoforge")) {
        capabilities {
            requireCapability 'net.neoforged:neoforge'
        }
    }
}

// Select runtimeElements rather than universalJar from the main source set
// If you don't believe it... try to remove this block, and run the following command:
// gradlew :neoforge:dependencyInsight --configuration clientRuntimeClasspath --dependency net.neoforged:neoforge --scan
configurations.clientRuntimeClasspath {
    attributes {
        attribute(Attribute.of("net.neoforged.neoforge.includes-minecraft", Boolean), true)
    }
}

neoDev {
    runs {
        configureEach {
            gameDirectory = layout.projectDir.dir("run/$name")
            systemProperty("terminal.ansi", "true")
        }
        client {
            client()
            sourceSet = sourceSets.client
            loadedMods = [joinedMod, neoDev.mods."neoforge-coremods"]
        }
        server {
            server()
            loadedMods = [commonMod, neoDev.mods."neoforge-coremods"]
        }
        gameTestServer {
            type = "gameTestServer"
            loadedMods = [commonMod, neoDev.mods."neoforge-coremods"]
        }
        data {
            // We perform client and server datagen in a single clientData run to avoid
            // having to juggle two generated resources folders and two runs for no additional benefit.
            clientData()
            sourceSet = sourceSets.client
            loadedMods = [joinedMod, neoDev.mods."neoforge-coremods"]
            programArguments.addAll '--mod', 'neoforge', '--flat', '--all', '--validate',
                    '--existing', rootProject.file("src/main/resources").absolutePath,
                    '--output', rootProject.file("src/generated/resources").absolutePath
        }
    }
}

generateAccessTransformers {
    // Make all state shards public
    classGroup(
            'render state shard classes', PUBLIC,
            innerClassesOf('net/minecraft/client/renderer/RenderStateShard')
    )
    // Make all state shard fields public
    fieldGroup(
            'render state shards', PUBLIC,
            named('net/minecraft/client/renderer/RenderStateShard'),
            fieldsOfType(classesWithSuperclass('net/minecraft/client/renderer/RenderStateShard'))
    )
    // Make all composite state builder methods public
    methodGroup(
            'composite state builder methods', PUBLIC,
            named('net/minecraft/client/renderer/RenderType$CompositeState$CompositeStateBuilder'),
            not(named('<init>'))
    )
    // Make all render pipeline snippet fields public
    fieldGroup(
            'render pipeline snippets', PUBLIC,
            named('net/minecraft/client/renderer/RenderPipelines'),
            fieldsOfType(named('com/mojang/blaze3d/pipeline/RenderPipeline$Snippet'))
    )

    // Make all block constructors public so they can be used by mods
    methodGroup(
            'block constructors', PUBLIC,
            classesWithSuperclass('net/minecraft/world/level/block/Block'),
            named('<init>')
    )
    // Make all particle constructors public so they can be used by mods
    methodGroup(
            'particle constructors', PUBLIC,
            classesWithSuperclass('net/minecraft/client/particle/Particle'),
            named('<init>')
    )

    // Make all criteria methods in the recipe provider protected so mods can use them
    methodGroup(
            'recipe criteria', PROTECTED,
            named('net/minecraft/data/recipes/RecipeProvider'),
            methodsReturning('net/minecraft/advancements/Criterion')
    )

    // getStepSound is package-private and abstract, so mods couldn't otherwise extend from AbstractSkeleton
    methodGroup(
            'skeleton step sound', PROTECTED,
            classesWithSuperclass('net/minecraft/world/entity/monster/AbstractSkeleton'),
            named('getStepSound')
    )

    // Make all noise generator setting factories public so mods can use them for custom dimensions
    methodGroup(
            'noise generator', PUBLIC,
            named('net/minecraft/world/level/levelgen/NoiseGeneratorSettings'),
            methodsReturning('net/minecraft/world/level/levelgen/NoiseGeneratorSettings')
    )

    fieldGroup(
            'biome effects builder', PROTECTED,
            named('net/minecraft/world/level/biome/BiomeSpecialEffects$Builder'),
            matchAny()
    )

    // Make all creative tab ids accessible
    fieldGroup(
            'creative tabs', PUBLIC,
            named('net/minecraft/world/item/CreativeModeTabs'),
            fieldsOfType(named('net/minecraft/resources/ResourceKey'))
    )

    // Make all villager item listings classes and constructors public for use in custom trades
    classGroup(
            'villager item listings', PUBLIC,
            classesWithSuperclass('net/minecraft/world/entity/npc/VillagerTrades$ItemListing')
    )
    methodGroup(
            'villager item listing constructors', PUBLIC,
            classesWithSuperclass('net/minecraft/world/entity/npc/VillagerTrades$ItemListing'),
            named('<init>')
    )
}

tasks.register('generateFinalizeSpawnTargets', GenerateFinalizeSpawnTargets.class) {
    group generateAccessTransformers.group
    description "Generate the targets for the finalizeSpawn MethodRedirector coremod"
    input = generateAccessTransformers.input
    output = rootProject.file("coremods/src/main/resources/net/neoforged/neoforge/coremods/finalize_spawn_targets.json")
}

tasks.withType(JavaCompile.class).configureEach {
    // Increase memory used during compilation, to avoid OutOfMemoryErrors
    options.forkOptions.memoryMaximumSize = '2g'
}

tasks.withType(Javadoc.class).configureEach {
    options.tags = [
            'apiNote:a:<em>API Note:</em>',
            'implSpec:a:<em>Implementation Requirements:</em>',
            'implNote:a:<em>Implementation Note:</em>'
    ]
    options.addStringOption('Xdoclint:all,-missing', '-public')
}

// Generates the neoforge.mods.toml so it contains a fully realized version number
final generateModMetadata = tasks.register('generateModMetadata', ProcessResources) {
    group = 'build'
    from(rootProject.file('src/main/neoforge.mods.toml')) {
        rename '(.*)', 'META-INF/$1'
    }
    into 'build/generated/modMetadata'

    // Exposed project properties
    Map<String, String> projectProperties = [
            'version',
    ].collectEntries { [it, project[it]] }

    // Ensure the resources get re-evaluate when the version changes
    inputs.properties projectProperties
    expand projectProperties
}
sourceSets.main.resources.srcDir generateModMetadata
net.neoforged.moddevgradle.internal.NeoDevFacade.runTaskOnProjectSync(project, generateModMetadata)

AdhocComponentWithVariants javaComponent = (AdhocComponentWithVariants) project.components.findByName("java")
// Ensure the two default variants are not published, since they
// contain Minecraft classes
javaComponent.withVariantsFromConfiguration(configurations.apiElements) {
    it.skip()
}
javaComponent.withVariantsFromConfiguration(configurations.runtimeElements) {
    it.skip()
}

// Resolvable configurations only
configurations {
    runtimeElements {
        attributes {
            // Add an attribute to disambiguate with the universalJar
            attribute(Attribute.of("net.neoforged.neoforge.includes-minecraft", Boolean), true)
        }
    }
    modDevBundle {
        canBeDeclared = false
        canBeResolved = false
        extendsFrom neoFormData
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, "data"))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
        }
        outgoing {
            capability("net.neoforged:neoforge-moddev-bundle:${project.version}")
        }
        javaComponent.addVariantsFromConfiguration(it) {} // Publish it
    }
    modDevConfig {
        canBeDeclared = false
        canBeResolved = false
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, "data"))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
        }
        outgoing {
            capability("net.neoforged:neoforge-moddev-config:${project.version}")
        }
        javaComponent.addVariantsFromConfiguration(it) {} // Publish it
    }
    installerJar {
        canBeDeclared = false
        canBeResolved = false
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EMBEDDED))
            // The installer targets JDK 8
            attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, 8)
        }
        outgoing {
            capability("net.neoforged:neoforge-installer:${project.version}")
        }
        // Publish it
        javaComponent.addVariantsFromConfiguration(it) {}
    }
    universalJar {
        canBeDeclared = false
        canBeResolved = false
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, java_version as Integer)
            attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements, LibraryElements.JAR))
        }
        // Publish it
        javaComponent.addVariantsFromConfiguration(it) {}
    }
    changelog {
        canBeDeclared = false
        canBeResolved = false
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
            attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, "changelog"))
        }
        // Publish it, but only for release versions
        if (!rootProject.isPreReleaseVersion) {
            javaComponent.addVariantsFromConfiguration(it) {}
        }
    }
    modDevApiElements {
        canBeDeclared = false
        canBeResolved = false
        extendsFrom libraries, userdevCompileOnly, neoFormDependencies
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_API))
        }
        outgoing {
            capability("net.neoforged:neoforge-dependencies:${project.version}")
        }
        javaComponent.addVariantsFromConfiguration(it) {}
    }
    modDevRuntimeElements {
        canBeDeclared = false
        canBeResolved = false
        extendsFrom libraries, neoFormDependencies
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
        }
        outgoing {
            capability("net.neoforged:neoforge-dependencies:${project.version}")
        }
        javaComponent.addVariantsFromConfiguration(it) {}
    }
    // Deprecated, but we'll keep it empty for backwards compatibility
    modDevModulePath {
        canBeDeclared = false
        canBeResolved = false
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
        }
        outgoing {
            capability("net.neoforged:neoforge-moddev-module-path:${project.version}")
        }
        javaComponent.addVariantsFromConfiguration(it) {}
    }
    modDevTestFixtures {
        canBeDeclared = false
        canBeResolved = false
        extendsFrom userdevTestFixtures
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
        }
        outgoing {
            capability("net.neoforged:neoforge-moddev-test-fixtures:${project.version}")
        }
        javaComponent.addVariantsFromConfiguration(it) {}
    }
}

sourcesJar {
    from sourceSets.client.allSource
}
javadoc {
    source += sourceSets.client.allSource
}

processResources {
    inputs.property("version", project.version)
    final version = project.version
    filesMatching("META-INF/neoforge.mods.toml") {
        expand([
                "global": [
                        "neoForgeVersion": version
                ]
        ])
    }
}

artifacts {
    modDevBundle(userdevJar) {
        setClassifier("userdev") // Legacy
    }
    modDevConfig(writeUserDevConfig.userDevConfig) {
        setClassifier("moddev-config")
    }
    universalJar(universalJar) {
        setClassifier("universal")
    }
    installerJar(installerJar) {
        setClassifier("installer")
    }
    changelog(createChangelog.outputFile) {
        builtBy(createChangelog)
        setClassifier("changelog")
        setExtension("txt")
    }
}

publishing {
    publications.create('NeoForge', MavenPublication) {
        groupId = project.group
        artifactId = project.name
        version = project.version

        from components.java

        versionMapping {
            usage('java-api') {
                fromResolutionOf('runtimeClasspath')
            }
            usage('java-runtime') {
                fromResolutionResult()
            }
        }

        pom {
            name = project.name
            description = 'Modifactions to Minecraft to enable mod developers.'
            url = 'https://github.com/NeoForged/NeoForge'

            scm {
                url = 'https://github.com/NeoForged/NeoForge'
                connection = 'scm:git:git://github.com/NeoForged/NeoForge.git'
                developerConnection = 'scm:git:git@github.com:NeoForged/NeoForge.git'
            }

            issueManagement {
                system = 'github'
                url = 'https://github.com/NeoForged/NeoForge/issues'
            }

            licenses {
                license {
                    name = 'LGPL 2.1'
                    url = 'https://github.com/NeoForged/NeoForge/blob/1.13-pre/LICENSE.txt'
                    distribution = 'repo'
                }
            }
        }
    }
    repositories {
        maven gradleutils.getPublishingMaven()
    }
}
