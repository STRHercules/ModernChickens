--- a/com/mojang/blaze3d/opengl/GlDevice.java
+++ b/com/mojang/blaze3d/opengl/GlDevice.java
@@ -58,6 +_,8 @@
     private final BufferStorage bufferStorage;
     private final Set<String> enabledExtensions = new HashSet<>();
     private final int uniformOffsetAlignment;
+    private final net.neoforged.neoforge.client.blaze3d.GpuDeviceProperties deviceProperties;
+    private final net.neoforged.neoforge.client.blaze3d.GpuDeviceFeatures enabledFeatures;
 
     public GlDevice(long p_410629_, int p_410525_, boolean p_409747_, BiFunction<ResourceLocation, ShaderType, String> p_410292_, boolean p_410647_) {
         GLFW.glfwMakeContextCurrent(p_410629_);
@@ -75,6 +_,9 @@
         this.encoder = new GlCommandEncoder(this);
         this.uniformOffsetAlignment = GL11.glGetInteger(35380);
         GL11.glEnable(34895);
+        deviceProperties = new net.neoforged.neoforge.client.blaze3d.opengl.ImmutableGlDeviceProperties(new net.neoforged.neoforge.client.blaze3d.opengl.DefaultGlDeviceProperties());
+        final var event = net.neoforged.fml.ModLoader.postEventWithReturn(new net.neoforged.neoforge.client.event.ConfigureGpuDeviceEvent(deviceProperties(), new net.neoforged.neoforge.client.blaze3d.opengl.DefaultGlDeviceFeatures()));
+        enabledFeatures = new net.neoforged.neoforge.client.blaze3d.opengl.ImmutableGlDeviceFeatures(event);
     }
 
     public GlDebugLabel debugLabels() {
@@ -188,6 +_,67 @@
         }
     }
 
+    /**
+     * Adopt an external OpenGL texture into a GpuTexture.
+     * The lifecycle of the OpenGL texture will not be tied to this GpuTexture and the external system is responsible
+     * for cleaning up the OpenGL texture. Calling this is a relatively expensive operation since we
+     * introspect the texture using OpenGL getters.
+     */
+    public GpuTexture createExternalTexture(@Nullable String label, int usage, int nativeId) {
+        var previousBinding = org.lwjgl.opengl.GL11.glGetInteger(org.lwjgl.opengl.GL11.GL_TEXTURE_BINDING_2D);
+        org.lwjgl.opengl.GL11.glBindTexture(org.lwjgl.opengl.GL11.GL_TEXTURE_2D, nativeId);
+
+        TextureFormat format = null;
+        // Get internal format
+        var internalFormat = org.lwjgl.opengl.GL11.glGetTexLevelParameteri(org.lwjgl.opengl.GL11.GL_TEXTURE_2D, 0, org.lwjgl.opengl.GL11.GL_TEXTURE_INTERNAL_FORMAT);
+        // Find matching TextureFormat. We only care about the internal format here, since we're not going to read/write pixels
+        for (var candidate : TextureFormat.values()) {
+            if (GlConst.toGlInternalId(candidate) == internalFormat || GlConst.toGlExternalId(candidate) == internalFormat) {
+                format = candidate;
+                break;
+            }
+        }
+
+        if (format == null) {
+            org.lwjgl.opengl.GL11.glBindTexture(org.lwjgl.opengl.GL11.GL_TEXTURE_2D, previousBinding);
+            throw new IllegalArgumentException("Couldn't find a matching vanilla TextureFormat for OpenGL internal format id " + internalFormat);
+        }
+
+        // Get width and height
+        int width = org.lwjgl.opengl.GL11.glGetTexLevelParameteri(org.lwjgl.opengl.GL11.GL_TEXTURE_2D, 0, org.lwjgl.opengl.GL11.GL_TEXTURE_WIDTH);
+        int height = org.lwjgl.opengl.GL11.glGetTexLevelParameteri(org.lwjgl.opengl.GL11.GL_TEXTURE_2D, 0, org.lwjgl.opengl.GL11.GL_TEXTURE_HEIGHT);
+
+        // Count mip levels by querying sizes until we get 0
+        int mipLevels = 1;
+        int mipWidth = width;
+        while (mipWidth > 1) {
+            int nextWidth = org.lwjgl.opengl.GL11.glGetTexLevelParameteri(org.lwjgl.opengl.GL11.GL_TEXTURE_2D, mipLevels, org.lwjgl.opengl.GL11.GL_TEXTURE_WIDTH);
+            if (nextWidth == 0) {
+                break;
+            }
+            mipLevels++;
+            mipWidth = nextWidth;
+        }
+
+        int depthOrLayers = 1;
+
+        org.lwjgl.opengl.GL11.glBindTexture(org.lwjgl.opengl.GL11.GL_TEXTURE_2D, previousBinding);
+
+        return createExternalTexture(usage, label, format, width, height, depthOrLayers, mipLevels, nativeId);
+    }
+
+    /**
+     * Create a new GPU texture from an existing texture whose lifecycle is externally managed.
+     */
+    public GpuTexture createExternalTexture(int usage, @Nullable String label, TextureFormat format, int width, int height, int depthOrLayers, int mipLevels, int nativeId) {
+        if (label == null) {
+            label = String.valueOf(nativeId);
+        }
+        GlTexture gltexture = new GlTexture(usage, label, format, width, height, depthOrLayers, mipLevels, nativeId, true);
+        this.debugLabels.applyLabel(gltexture);
+        return gltexture;
+    }
+
     @Override
     public GpuTextureView createTextureView(GpuTexture p_423640_) {
         return this.createTextureView(p_423640_, 0, p_423640_.getMipLevels());
@@ -435,5 +_,15 @@
             String s = this.id + " (" + this.type + ")";
             return !this.defines.isEmpty() ? s + " with " + this.defines : s;
         }
+    }
+
+    @Override
+    public net.neoforged.neoforge.client.blaze3d.GpuDeviceProperties deviceProperties() {
+        return deviceProperties;
+    }
+
+    @Override
+    public net.neoforged.neoforge.client.blaze3d.GpuDeviceFeatures enabledFeatures() {
+        return enabledFeatures;
     }
 }
