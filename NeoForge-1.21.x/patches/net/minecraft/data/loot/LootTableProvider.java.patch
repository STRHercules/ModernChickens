--- a/net/minecraft/data/loot/LootTableProvider.java
+++ b/net/minecraft/data/loot/LootTableProvider.java
@@ -61,7 +_,8 @@
     private CompletableFuture<?> run(CachedOutput p_324447_, HolderLookup.Provider p_323978_) {
         WritableRegistry<LootTable> writableregistry = new MappedRegistry<>(Registries.LOOT_TABLE, Lifecycle.experimental());
         Map<RandomSupport.Seed128bit, ResourceLocation> map = new Object2ObjectOpenHashMap<>();
-        this.subProviders.forEach(p_344197_ -> p_344197_.provider().apply(p_323978_).generate((p_380827_, p_380828_) -> {
+        Map<LootTable, List<net.neoforged.neoforge.common.conditions.ICondition>> conditionsPerTable = new java.util.IdentityHashMap<>();
+        getTables().forEach(p_344197_ -> p_344197_.provider().apply(p_323978_).generate((p_380827_, p_380828_) -> {
             ResourceLocation resourcelocation = sequenceIdForLootTable(p_380827_);
             ResourceLocation resourcelocation1 = map.put(RandomSequence.seedForKey(resourcelocation), resourcelocation);
             if (resourcelocation1 != null) {
@@ -71,24 +_,18 @@
             p_380828_.setRandomSequence(resourcelocation);
             LootTable loottable = p_380828_.setParamSet(p_344197_.paramSet).build();
             writableregistry.register(p_380827_, loottable, RegistrationInfo.BUILT_IN);
+            var conditions = p_380828_.buildConditions();
+            if (!conditions.isEmpty()) {
+                conditionsPerTable.put(loottable, conditions);
+            }
         }));
         writableregistry.freeze();
         ProblemReporter.Collector problemreporter$collector = new ProblemReporter.Collector();
         HolderGetter.Provider holdergetter$provider = new RegistryAccess.ImmutableRegistryAccess(List.of(writableregistry)).freeze();
         ValidationContext validationcontext = new ValidationContext(problemreporter$collector, LootContextParamSets.ALL_PARAMS, holdergetter$provider);
 
-        for (ResourceKey<LootTable> resourcekey : Sets.difference(this.requiredTables, writableregistry.registryKeySet())) {
-            problemreporter$collector.report(new LootTableProvider.MissingTableProblem(resourcekey));
-        }
+        validate(writableregistry, validationcontext, problemreporter$collector);
 
-        writableregistry.listElements()
-            .forEach(
-                p_421302_ -> p_421302_.value()
-                    .validate(
-                        validationcontext.setContextKeySet(p_421302_.value().getParamSet())
-                            .enterElement(new ProblemReporter.RootElementPathElement(p_421302_.key()), p_421302_.key())
-                    )
-            );
         if (!problemreporter$collector.isEmpty()) {
             problemreporter$collector.forEach((p_421299_, p_421300_) -> LOGGER.warn("Found validation problem in {}: {}", p_421299_, p_421300_.description()));
             throw new IllegalStateException("Failed to validate loot tables, see logs");
@@ -97,9 +_,29 @@
                 ResourceKey<LootTable> resourcekey1 = p_335193_.getKey();
                 LootTable loottable = p_335193_.getValue();
                 Path path = this.pathProvider.json(resourcekey1.location());
-                return DataProvider.saveStable(p_324447_, p_323978_, LootTable.DIRECT_CODEC, loottable, path);
+                var conditional = new net.neoforged.neoforge.common.conditions.WithConditions<>(conditionsPerTable.getOrDefault(loottable, List.of()), loottable);
+                return DataProvider.saveStable(p_324447_, p_323978_, LootTable.CONDITIONAL_DIRECT_CODEC, java.util.Optional.of(conditional), path);
             }).toArray(CompletableFuture[]::new));
         }
+    }
+
+    public List<LootTableProvider.SubProviderEntry> getTables() {
+        return this.subProviders;
+    }
+
+    protected void validate(WritableRegistry<LootTable> writableregistry, ValidationContext validationcontext, ProblemReporter.Collector problemreporter$collector) {
+        for (ResourceKey<LootTable> resourcekey : Sets.difference(this.requiredTables, writableregistry.registryKeySet())) {
+            problemreporter$collector.report(new LootTableProvider.MissingTableProblem(resourcekey));
+        }
+
+        writableregistry.listElements()
+                .forEach(
+                        p_380823_ -> p_380823_.value()
+                                .validate(
+                                        validationcontext.setContextKeySet(p_380823_.value().getParamSet())
+                                                .enterElement(new ProblemReporter.RootElementPathElement(p_380823_.key()), p_380823_.key())
+                                )
+                );
     }
 
     private static ResourceLocation sequenceIdForLootTable(ResourceKey<LootTable> p_336172_) {
