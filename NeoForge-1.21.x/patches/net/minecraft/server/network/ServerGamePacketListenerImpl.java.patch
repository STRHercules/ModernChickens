--- a/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -472,18 +_,21 @@
 
                 if (flag1 && serverlevel.noCollision(entity, aabb) || this.isEntityCollidingWithAnythingNew(serverlevel, entity, aabb, d3, d4, d5)) {
                     entity.absSnapTo(d0, d1, d2, f, f1);
+                    resyncPlayerWithVehicle(entity); // Neo - Resync player position on vehicle moving
                     this.send(ClientboundMoveVehiclePacket.fromEntity(entity));
                     entity.removeLatestMovementRecording();
                     return;
                 }
 
                 entity.absSnapTo(d3, d4, d5, f, f1);
+                resyncPlayerWithVehicle(entity); // Neo - Resync player position on vehicle moving
                 this.player.level().getChunkSource().move(this.player);
                 Vec3 vec3 = new Vec3(entity.getX() - d0, entity.getY() - d1, entity.getZ() - d2);
                 this.handlePlayerKnownMovement(vec3);
                 entity.setOnGroundWithMovement(p_9876_.onGround(), vec3);
                 entity.doCheckFallDamage(vec3.x, vec3.y, vec3.z, p_9876_.onGround());
                 this.player.checkMovementStatistics(vec3.x, vec3.y, vec3.z);
+                this.player.checkRidingStatistics(vec3.x, vec3.y, vec3.z); // Neo: check riding stats too as vanilla checks them in rideTick based on the assumption that Entity#rideTick will move the entity, which we break
                 this.clientVehicleIsFloating = d11 >= -0.03125
                     && !flag
                     && !this.server.allowFlight()
@@ -497,6 +_,23 @@
         }
     }
 
+    private void resyncPlayerWithVehicle(Entity vehicle) {
+        Vec3 oldPos = this.player.position();
+        float yRot = this.player.getYRot();
+        float xRot = this.player.getXRot();
+        float yHeadRot = this.player.getYHeadRot();
+
+        vehicle.positionRider(this.player);
+
+        // preserve old rotation and store old position in xo/yo/zo
+        this.player.setYRot(yRot);
+        this.player.setXRot(xRot);
+        this.player.setYHeadRot(yHeadRot);
+        this.player.xo = oldPos.x;
+        this.player.yo = oldPos.y;
+        this.player.zo = oldPos.z;
+    }
+
     private boolean noBlocksAround(Entity p_9794_) {
         return p_9794_.level()
             .getBlockStates(p_9794_.getBoundingBox().inflate(0.0625).expandTowards(0.0, -0.55, 0.0))
@@ -676,7 +_,7 @@
             if (serverlevel.isLoaded(blockpos)) {
                 BlockState blockstate = serverlevel.getBlockState(blockpos);
                 boolean flag = this.player.hasInfiniteMaterials() && p_382999_.includeData();
-                ItemStack itemstack = blockstate.getCloneItemStack(serverlevel, blockpos, flag);
+                ItemStack itemstack = blockstate.getCloneItemStack(blockpos, serverlevel, flag, player);
                 if (!itemstack.isEmpty()) {
                     if (flag) {
                         addBlockDataToItem(blockstate, serverlevel, blockpos, itemstack);
@@ -1095,7 +_,7 @@
                                         && !flag1
                                         && !this.player.isSpectator()
                                         && !this.server.allowFlight()
-                                        && !this.player.getAbilities().mayfly
+                                        && !this.player.mayFly()
                                         && !this.player.hasEffect(MobEffects.LEVITATION)
                                         && !flag
                                         && !flag3
@@ -1210,9 +_,10 @@
             switch (serverboundplayeractionpacket$action) {
                 case SWAP_ITEM_WITH_OFFHAND:
                     if (!this.player.isSpectator()) {
-                        ItemStack itemstack = this.player.getItemInHand(InteractionHand.OFF_HAND);
-                        this.player.setItemInHand(InteractionHand.OFF_HAND, this.player.getItemInHand(InteractionHand.MAIN_HAND));
-                        this.player.setItemInHand(InteractionHand.MAIN_HAND, itemstack);
+                        var event = net.neoforged.neoforge.common.CommonHooks.onLivingSwapHandItems(this.player);
+                        if (event.isCanceled()) return;
+                        this.player.setItemInHand(InteractionHand.OFF_HAND, event.getItemSwappedToOffHand());
+                        this.player.setItemInHand(InteractionHand.MAIN_HAND, event.getItemSwappedToMainHand());
                         this.player.stopUsingItem();
                     }
 
@@ -1240,7 +_,7 @@
                         .handleBlockBreakAction(
                             blockpos, serverboundplayeractionpacket$action, p_9889_.getDirection(), this.player.level().getMaxY(), p_9889_.getSequence()
                         );
-                    this.ackBlockChangesUpTo(p_9889_.getSequence());
+                    this.player.connection.ackBlockChangesUpTo = p_9889_.getSequence();
                     return;
                 default:
                     throw new IllegalArgumentException("Invalid player action");
@@ -1262,7 +_,7 @@
     public void handleUseItemOn(ServerboundUseItemOnPacket p_9930_) {
         PacketUtils.ensureRunningOnSameThread(p_9930_, this, this.player.level());
         if (this.player.hasClientLoaded()) {
-            this.ackBlockChangesUpTo(p_9930_.getSequence());
+            this.player.connection.ackBlockChangesUpTo = p_9930_.getSequence();
             ServerLevel serverlevel = this.player.level();
             InteractionHand interactionhand = p_9930_.getHand();
             ItemStack itemstack = this.player.getItemInHand(interactionhand);
@@ -1418,8 +_,9 @@
                 }
 
                 CompletableFuture<FilteredText> completablefuture = this.filterTextPacket(playerchatmessage.signedContent());
-                Component component = this.server.getChatDecorator().decorate(this.player, playerchatmessage.decoratedContent());
+                Component component = net.neoforged.neoforge.common.CommonHooks.getServerChatSubmittedDecorator().decorate(this.player, playerchatmessage.decoratedContent());
                 this.chatMessageChain.append(completablefuture, p_300785_ -> {
+                    if (component == null) return; // Forge: ServerChatEvent was canceled if this is null.
                     PlayerChatMessage playerchatmessage1 = playerchatmessage.withUnsignedContent(component).filter(p_300785_.mask());
                     this.broadcastChatMessage(playerchatmessage1);
                 });
@@ -1753,7 +_,11 @@
 
                             @Override
                             public void onInteraction(InteractionHand p_143682_, Vec3 p_143683_) {
-                                this.performInteraction(p_143682_, (p_143686_, p_143687_, p_143688_) -> p_143687_.interactAt(p_143686_, p_143683_, p_143688_));
+                                this.performInteraction(p_143682_, (p_143686_, p_143687_, p_143688_) -> {
+                                    InteractionResult onInteractEntityAtResult = net.neoforged.neoforge.common.CommonHooks.onInteractEntityAt(player, entity, p_143683_, p_143682_);
+                                    if (onInteractEntityAtResult != null) return onInteractEntityAtResult;
+                                    return p_143687_.interactAt(p_143686_, p_143683_, p_143688_);
+                                });
                             }
 
                             @Override
@@ -1954,14 +_,16 @@
     @Override
     public void handlePlayerAbilities(ServerboundPlayerAbilitiesPacket p_9887_) {
         PacketUtils.ensureRunningOnSameThread(p_9887_, this, this.player.level());
-        this.player.getAbilities().flying = p_9887_.isFlying() && this.player.getAbilities().mayfly;
+        this.player.getAbilities().flying = p_9887_.isFlying() && this.player.mayFly();
     }
 
     @Override
     public void handleClientInformation(ServerboundClientInformationPacket p_301979_) {
         PacketUtils.ensureRunningOnSameThread(p_301979_, this, this.player.level());
         boolean flag = this.player.isModelPartShown(PlayerModelPart.HAT);
+        net.minecraft.server.level.ClientInformation oldInfo = this.player.clientInformation();
         this.player.updateOptions(p_301979_.information());
+        net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.entity.player.ClientInformationUpdatedEvent(this.player, oldInfo, p_301979_.information()));
         if (this.player.isModelPartShown(PlayerModelPart.HAT) != flag) {
             this.server.getPlayerList().broadcastAll(new ClientboundPlayerInfoUpdatePacket(ClientboundPlayerInfoUpdatePacket.Action.UPDATE_HAT, this.player));
         }
@@ -2037,7 +_,7 @@
             this.connection
                 .setupInboundProtocol(
                     ConfigurationProtocols.SERVERBOUND,
-                    new ServerConfigurationPacketListenerImpl(this.server, this.connection, this.createCookie(this.player.clientInformation()))
+                    new ServerConfigurationPacketListenerImpl(this.server, this.connection, this.createCookie(this.player.clientInformation(), this.connectionType))
                 );
         }
     }
@@ -2072,6 +_,7 @@
 
     @Override
     public void handleCustomPayload(ServerboundCustomPayloadPacket p_333887_) {
+        super.handleCustomPayload(p_333887_); // Neo: Call super to invoke modded payload handling.
     }
 
     @Override
