--- a/net/minecraft/world/level/block/entity/HopperBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/HopperBlockEntity.java
@@ -82,6 +_,41 @@
         this.getItems().set(p_59315_, p_59316_);
         p_59316_.limitSize(this.getMaxStackSize(p_59316_));
     }
+    // Neo: Make the hopper cooldown time transactional (it may change when items are inserted)
+    private final net.neoforged.neoforge.transfer.transaction.SnapshotJournal<Integer> cooldownTimeJournal = new net.neoforged.neoforge.transfer.transaction.SnapshotJournal<>() {
+        @Override
+        protected Integer createSnapshot() {
+            return cooldownTime;
+        }
+        @Override
+        protected void revertToSnapshot(Integer snapshot) {
+            cooldownTime = snapshot;
+        }
+    };
+
+    // Neo: Checks if the hopper was empty just before the insertion of `amountChange` at index `slot`.
+    private boolean wasEmpty(int slot, int amountChange) {
+        if (items.get(slot).getCount() != amountChange) return false;
+        for (int i = 0; i < items.size(); ++i) {
+            if (i != slot && !items.get(i).isEmpty()) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    @Override
+    public void onTransfer(int slot, int amountChange, net.neoforged.neoforge.transfer.transaction.TransactionContext transaction) {
+        // If we just went from empty to something in the hopper, reset the cooldown.
+        if (amountChange > 0 && !isOnCustomCooldown() && wasEmpty(slot, amountChange)) {
+            cooldownTimeJournal.updateSnapshots(transaction);
+            // This cooldown is always set to 8 in vanilla with one exception:
+            // Hopper -> Hopper transfer sets this cooldown to 7 when this hopper
+            // has not been updated as recently as the one pushing items into it.
+            // Hopper <-> hopper interactions don't use transactions so we don't need to worry about that.
+            setCooldown(MOVE_ITEM_SPEED);
+        }
+    }
 
     @Override
     public void setBlockState(BlockState p_326468_) {
@@ -139,10 +_,11 @@
     }
 
     private static boolean ejectItems(Level p_155563_, BlockPos p_155564_, HopperBlockEntity p_326256_) {
-        Container container = getAttachedContainer(p_155563_, p_155564_, p_326256_);
-        if (container == null) {
+        var containerOrHandler = getContainerOrHandlerAt(p_155563_, p_155564_.relative(p_326256_.facing), p_326256_.facing.getOpposite());
+        if (containerOrHandler.isEmpty()) {
             return false;
-        } else {
+        } else if (containerOrHandler.container() != null) {
+            Container container = containerOrHandler.container();
             Direction direction = p_326256_.facing.getOpposite();
             if (isFullContainer(container, direction)) {
                 return false;
@@ -166,6 +_,8 @@
 
                 return false;
             }
+        } else {
+            return net.neoforged.neoforge.transfer.item.VanillaInventoryCodeHooks.insertHook(p_326256_, containerOrHandler.itemHandler());
         }
     }
 
@@ -216,8 +_,9 @@
     public static boolean suckInItems(Level p_155553_, Hopper p_155554_) {
         BlockPos blockpos = BlockPos.containing(p_155554_.getLevelX(), p_155554_.getLevelY() + 1.0, p_155554_.getLevelZ());
         BlockState blockstate = p_155553_.getBlockState(blockpos);
-        Container container = getSourceContainer(p_155553_, p_155554_, blockpos, blockstate);
-        if (container != null) {
+        var containerOrHandler = getSourceContainerOrHandler(p_155553_, p_155554_, blockpos, blockstate);
+        if (containerOrHandler.container() != null) {
+            Container container = containerOrHandler.container();
             Direction direction = Direction.DOWN;
 
             for (int i : getSlots(container, direction)) {
@@ -227,6 +_,8 @@
             }
 
             return false;
+        } else if (containerOrHandler.itemHandler() != null) {
+            return net.neoforged.neoforge.transfer.item.VanillaInventoryCodeHooks.extractHook(p_155554_, containerOrHandler.itemHandler());
         } else {
             boolean flag = p_155554_.isGridAligned()
                 && blockstate.isCollisionShapeFullBlock(p_155553_, blockpos)
@@ -356,6 +_,8 @@
         return p_155590_.getEntitiesOfClass(ItemEntity.class, aabb, EntitySelector.ENTITY_STILL_ALIVE);
     }
 
+    /** @deprecated Use IItemHandler capability instead. To preserve Container-specific interactions, use {@link #getContainerOrHandlerAt} and handle both cases. */
+    @Deprecated
     @Nullable
     public static Container getContainerAt(Level p_59391_, BlockPos p_59392_) {
         return getContainerAt(p_59391_, p_59392_, p_59391_.getBlockState(p_59392_), p_59392_.getX() + 0.5, p_59392_.getY() + 0.5, p_59392_.getZ() + 0.5);
@@ -397,6 +_,28 @@
         return !list.isEmpty() ? (Container)list.get(p_326325_.random.nextInt(list.size())) : null;
     }
 
+    private static net.neoforged.neoforge.transfer.item.ContainerOrHandler getSourceContainerOrHandler(Level p_155597_, Hopper p_155598_, BlockPos p_326315_, BlockState p_326093_) {
+        return getContainerOrHandlerAt(p_155597_, p_326315_, p_326093_, p_155598_.getLevelX(), p_155598_.getLevelY() + 1.0, p_155598_.getLevelZ(), Direction.DOWN);
+    }
+
+    public static net.neoforged.neoforge.transfer.item.ContainerOrHandler getContainerOrHandlerAt(Level level, BlockPos pos, @Nullable Direction side) {
+        return getContainerOrHandlerAt(
+                level, pos, level.getBlockState(pos), (double)pos.getX() + 0.5, (double)pos.getY() + 0.5, (double)pos.getZ() + 0.5, side
+        );
+    }
+
+    private static net.neoforged.neoforge.transfer.item.ContainerOrHandler getContainerOrHandlerAt(Level level, BlockPos pos, BlockState state, double x, double y, double z, @Nullable Direction side) {
+        Container container = getBlockContainer(level, pos, state);
+        if (container != null) {
+            return new net.neoforged.neoforge.transfer.item.ContainerOrHandler(container, null);
+        }
+        var blockItemHandler = level.getCapability(net.neoforged.neoforge.capabilities.Capabilities.Item.BLOCK, pos, state, null, side);
+        if (blockItemHandler != null) {
+            return new net.neoforged.neoforge.transfer.item.ContainerOrHandler(null, blockItemHandler);
+        }
+        return net.neoforged.neoforge.transfer.item.VanillaInventoryCodeHooks.getEntityContainerOrHandler(level, x, y, z, side);
+    }
+
     private static boolean canMergeItems(ItemStack p_59345_, ItemStack p_59346_) {
         return p_59345_.getCount() <= p_59345_.getMaxStackSize() && ItemStack.isSameItemSameComponents(p_59345_, p_59346_);
     }
@@ -454,5 +_,9 @@
     @Override
     protected AbstractContainerMenu createMenu(int p_59312_, Inventory p_59313_) {
         return new HopperMenu(p_59312_, p_59313_, this);
+    }
+
+    public long getLastUpdateTime() {
+        return this.tickedGameTime;
     }
 }
