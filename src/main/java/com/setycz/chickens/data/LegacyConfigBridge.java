package com.setycz.chickens.data;

import com.setycz.chickens.ChickensRegistryItem;
import com.setycz.chickens.config.ChickensConfigValues;
import net.minecraft.core.registries.BuiltInRegistries;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.ItemStack;
import net.neoforged.fml.loading.FMLPaths;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Comparator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.TreeMap;

/**
 * Bridges the legacy Forge {@code chickens.cfg} format so existing installations
 * can keep using the configuration layout they are familiar with. The bridge
 * imports key values into the properties-driven system and re-exports an updated
 * cfg file after bootstrap.
 */
public final class LegacyConfigBridge {
    private static final Logger LOGGER = LoggerFactory.getLogger("ChickensLegacyConfig");

    private LegacyConfigBridge() {
    }

    public static void importIfPresent(Properties props, List<ChickensRegistryItem> chickens) {
        Path legacyPath = legacyConfigPath();
        if (!Files.exists(legacyPath)) {
            return;
        }
        Map<String, ChickensRegistryItem> byName = mapByName(chickens);
        try (BufferedReader reader = Files.newBufferedReader(legacyPath, StandardCharsets.UTF_8)) {
            String currentSection = null;
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty() || line.startsWith("#")) {
                    continue;
                }
                if (line.endsWith("{")) {
                    currentSection = line.substring(0, line.length() - 1).trim();
                    continue;
                }
                if (line.equals("}")) {
                    currentSection = null;
                    continue;
                }
                int eq = line.indexOf('=');
                if (eq <= 0) {
                    continue;
                }
                String key = line.substring(0, eq).trim();
                String value = line.substring(eq + 1).trim();
                int colon = key.indexOf(':');
                if (colon >= 0) {
                    key = key.substring(colon + 1);
                }
                if (currentSection == null) {
                    continue;
                }
                if ("general".equalsIgnoreCase(currentSection)) {
                    applyGeneralValue(props, key, value);
                } else {
                    ChickensRegistryItem chicken = byName.get(currentSection);
                    if (chicken != null) {
                        applyChickenValue(props, chicken, key, value);
                    }
                }
            }
        } catch (IOException ex) {
            LOGGER.warn("Failed to read legacy chickens.cfg", ex);
        }
    }

    public static void export(Properties props, List<ChickensRegistryItem> chickens, ChickensConfigValues general) {
        Path legacyPath = legacyConfigPath();
        try {
            Files.createDirectories(legacyPath.getParent());
        } catch (IOException ex) {
            LOGGER.warn("Unable to create configuration directory for legacy cfg export", ex);
            return;
        }

        List<ChickensRegistryItem> ordered = chickens.stream()
                .sorted(Comparator.comparingInt(ChickensRegistryItem::getId))
                .toList();

        try (BufferedWriter writer = Files.newBufferedWriter(legacyPath, StandardCharsets.UTF_8)) {
            writer.write("# Auto-generated by Modern Chickens to maintain legacy configuration compatibility.\n");
            writer.write("# Editing this file will update the modern configuration on next launch.\n\n");

            writer.write("general {\n");
            writer.write(String.format(Locale.ROOT, "    I:spawnProbability=%d%n", general.getSpawnProbability()));
            writer.write(String.format(Locale.ROOT, "    I:minBroodSize=%d%n", general.getMinBroodSize()));
            writer.write(String.format(Locale.ROOT, "    I:maxBroodSize=%d%n", general.getMaxBroodSize()));
            writer.write(String.format(Locale.ROOT, "    D:netherSpawnChanceMultiplier=%.3f%n", general.getNetherSpawnChanceMultiplier()));
            writer.write(String.format(Locale.ROOT, "    B:alwaysShowStats=%s%n", general.isAlwaysShowStats()));
            writer.write(String.format(Locale.ROOT, "    D:roostSpeed=%.3f%n", general.getRoostSpeedMultiplier()));
            writer.write(String.format(Locale.ROOT, "    D:breederSpeed=%.3f%n", general.getBreederSpeedMultiplier()));
            writer.write(String.format(Locale.ROOT, "    B:disableEggLaying=%s%n", general.isVanillaEggLayingDisabled()));
            writer.write(String.format(Locale.ROOT, "    I:collectorScanRange=%d%n", general.getCollectorScanRange()));
            writer.write(String.format(Locale.ROOT, "    B:avianFluxEffectsEnabled=%s%n", general.isAvianFluxEffectsEnabled()));
            writer.write(String.format(Locale.ROOT, "    D:fluxEggCapacityMultiplier=%.3f%n", general.getFluxEggCapacityMultiplier()));
            writer.write(String.format(Locale.ROOT, "    I:avianFluxCapacity=%d%n", general.getAvianFluxCapacity()));
            writer.write(String.format(Locale.ROOT, "    I:avianFluxMaxReceive=%d%n", general.getAvianFluxMaxReceive()));
            writer.write(String.format(Locale.ROOT, "    I:avianFluxMaxExtract=%d%n", general.getAvianFluxMaxExtract()));
            writer.write("}\n\n");

            for (ChickensRegistryItem chicken : ordered) {
                String category = chicken.getEntityName();
                writer.write(category + " {\n");
                String prefix = prefixFor(category);
                writer.write(String.format(Locale.ROOT, "    B:enabled=%s%n", getBoolean(props, prefix + "enabled", true)));
                writer.write(String.format(Locale.ROOT, "    D:layCoefficient=%s%n", getString(props, prefix + "layCoefficient", "1.0")));
                writer.write(String.format(Locale.ROOT, "    S:spawnType=%s%n", getString(props, prefix + "spawnType", chicken.getSpawnType().name())));
                writer.write(String.format(Locale.ROOT, "    S:parent1=%s%n", getString(props, prefix + "parent1", chicken.getParent1() != null ? chicken.getParent1().getEntityName() : "")));
                writer.write(String.format(Locale.ROOT, "    S:parent2=%s%n", getString(props, prefix + "parent2", chicken.getParent2() != null ? chicken.getParent2().getEntityName() : "")));

                writeItemEntry(writer, props, prefix, "egg", chicken.createLayItem());
                writeItemEntry(writer, props, prefix, "drop", chicken.createDropItem());

                writer.write("}\n\n");
            }
        } catch (IOException ex) {
            LOGGER.warn("Failed to write legacy chickens.cfg", ex);
        }
    }

    private static void applyGeneralValue(Properties props, String key, String value) {
        switch (key) {
            case "spawnProbability" -> props.setProperty("general.spawnProbability", value);
            case "minBroodSize" -> props.setProperty("general.minBroodSize", value);
            case "maxBroodSize" -> props.setProperty("general.maxBroodSize", value);
            case "netherSpawnChanceMultiplier" -> props.setProperty("general.netherSpawnChanceMultiplier", value);
            case "alwaysShowStats" -> props.setProperty("general.alwaysShowStats", value);
            case "roostSpeed" -> props.setProperty("general.roostSpeedMultiplier", value);
            case "breederSpeed" -> props.setProperty("general.breederSpeedMultiplier", value);
            case "disableEggLaying" -> props.setProperty("general.disableVanillaEggLaying", value);
            case "collectorScanRange" -> props.setProperty("general.collectorScanRange", value);
            case "avianFluxEffectsEnabled" -> props.setProperty("general.avianFluxEffectsEnabled", value);
            case "fluxEggCapacityMultiplier" -> props.setProperty("general.fluxEggCapacityMultiplier", value);
            case "avianFluxCapacity" -> props.setProperty("general.avianFluxCapacity", value);
            case "avianFluxMaxReceive" -> props.setProperty("general.avianFluxMaxReceive", value);
            case "avianFluxMaxExtract" -> props.setProperty("general.avianFluxMaxExtract", value);
            default -> {
            }
        }
    }

    private static void applyChickenValue(Properties props, ChickensRegistryItem chicken, String key, String value) {
        String prefix = prefixFor(chicken.getEntityName());
        switch (key) {
            case "enabled" -> props.setProperty(prefix + "enabled", value);
            case "layCoefficient" -> props.setProperty(prefix + "layCoefficient", value);
            case "spawnType" -> props.setProperty(prefix + "spawnType", value);
            case "parent1" -> props.setProperty(prefix + "parent1", value);
            case "parent2" -> props.setProperty(prefix + "parent2", value);
            case "layItemName" -> props.setProperty(prefix + "eggItem", value);
            case "layItemAmount" -> props.setProperty(prefix + "eggCount", value);
            case "layItemMeta" -> props.setProperty(prefix + "eggType", value);
            case "dropItemName" -> props.setProperty(prefix + "dropItem", value);
            case "dropItemAmount" -> props.setProperty(prefix + "dropCount", value);
            case "dropItemMeta" -> props.setProperty(prefix + "dropType", value);
            default -> {
            }
        }
    }

    private static void writeItemEntry(BufferedWriter writer, Properties props, String prefix, String kind, ItemStack stack) throws IOException {
        String itemKey = prefix + kind + "Item";
        String countKey = prefix + kind + "Count";
        String metaKey = prefix + kind + "Type";

        String itemId = getString(props, itemKey, getItemId(stack));
        String count = getString(props, countKey, Integer.toString(stack.getCount()));
        String type = getString(props, metaKey, "0");

        String legacyPrefix = "egg".equals(kind) ? "lay" : "drop";
        writer.write(String.format(Locale.ROOT, "    S:%sItemName=%s%n", legacyPrefix, itemId));
        writer.write(String.format(Locale.ROOT, "    I:%sItemAmount=%s%n", legacyPrefix, count));
        writer.write(String.format(Locale.ROOT, "    I:%sItemMeta=%s%n", legacyPrefix, type));
    }

    private static Map<String, ChickensRegistryItem> mapByName(List<ChickensRegistryItem> chickens) {
        Map<String, ChickensRegistryItem> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
        for (ChickensRegistryItem chicken : chickens) {
            result.put(chicken.getEntityName(), chicken);
        }
        return result;
    }

    private static String prefixFor(String entityName) {
        return "chicken." + entityName + ".";
    }

    private static String getString(Properties props, String key, String fallback) {
        return props.getProperty(key, fallback);
    }

    private static String getBoolean(Properties props, String key, boolean fallback) {
        return props.getProperty(key, Boolean.toString(fallback));
    }

    private static Path legacyConfigPath() {
        return FMLPaths.CONFIGDIR.get().resolve("chickens.cfg");
    }

    private static String getItemId(ItemStack stack) {
        ResourceLocation id = BuiltInRegistries.ITEM.getKey(stack.getItem());
        return id != null ? id.toString() : "minecraft:air";
    }
}
